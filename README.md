# Deep Faker

[![Discord](https://img.shields.io/badge/Discord-Join%20Community-7289da?style=for-the-badge&logo=discord&logoColor=white)](https://discord.gg/UsfVqRsB)

**Deep Faker** is a Python-native event generator that creates realistic, stateful event streams with complex entity relationships and temporal patterns. Perfect for testing event-driven systems, generating training data, and simulating real-world user behaviors.

## Features

- **Stateful Entities**: Track entity states across events with automatic mutations
- **Realistic Flows**: Define complex user journeys with temporal patterns and decay rates
- **Multiple Outputs**: Stream to console, files, Kafka, MySQL, and more
- **Flexible Event Schemas**: Use Pydantic models with faker integration
- **Implicit State Management**: Automatic entity availability tracking and flow isolation
- **Compact IDs**: URL-safe short UUIDs for efficient event identification

## Quick Start

### Installation

```bash
pip install deep-faker
```

### Basic Example

```python
from deep_faker import (
    BaseEvent, Entity, Field, StateField, Simulation, 
    FlowContext, NewEvent, StdOutOutput
)

# Define an event schema
class UserLogin(BaseEvent):
    user_id: str = Field(faker="shortuuid", length=8)
    login_time: str = Field(faker="date_time")
    platform: str = Field(faker="random_element", elements=["web", "mobile", "api"])

# Define an entity to track state
class User(Entity):
    source_event = UserLogin
    primary_key = "user_id"
    
    login_count: int = StateField(default=0, type_=int)
    last_platform: str = StateField(default="unknown", type_=str)

# Create a simulation
sim = Simulation(
    duration="2m",
    start_time="now", 
    n_flows=3,
    initial_entities={User: 5}
)

# Define a flow
@sim.flow(initiation_weight=1.0)
def user_login_flow(ctx: FlowContext):
    yield NewEvent(ctx, UserLogin, save_entity=User)

# Add output and run
sim.add_output(StdOutOutput())
sim.run()
```

This generates realistic login events with stateful user tracking:

```json
{"sys__eid": "a2Wr6uwJ4ZVJ", "sys__ets": 1754862710365, "sys__sid": "U2FgUQ3g", "user_id": "f92Xc91f", "login_time": "2024-03-15 14:32:10", "platform": "mobile", "event_type": "UserLogin"}
```

## Core Concepts

### Events

Events are the fundamental data structures generated by Deep Faker. They extend `BaseEvent` and use Pydantic for validation and faker for realistic data generation.

```python
class OrderPlaced(BaseEvent):
    """Customer places an order"""
    order_id: str = Field(faker="shortuuid", length=12)
    user_id: str = Field(faker="shortuuid", length=8) 
    total_amount: float = Field(faker="pyfloat", min_value=10.0, max_value=500.0)
    currency: str = Field(faker="random_element", elements=["USD", "EUR", "GBP"])
    order_date: datetime = Field(faker="now")
```

**Global Event Properties:**
- `sys__eid`: 12-character short UUID for event identification  
- `sys__ets`: Event timestamp in milliseconds
- `sys__sid`: 8-character session ID linking related events

### Fields

Fields define event properties with automatic fake data generation using the `Field` function:

```python
# Basic faker types
name: str = Field(faker="name")
email: str = Field(faker="email") 
age: int = Field(faker="random_int", min=18, max=80)

# Short UUIDs (recommended for IDs)
user_id: str = Field(faker="shortuuid", length=8)
session_id: str = Field(faker="shortuuid", length=12)

# Custom elements
status: str = Field(faker="random_element", elements=["active", "pending", "cancelled"])
```

**Available Faker Types:**
- `shortuuid`: Compact URL-safe UUIDs (specify `length`)
- `uuid4`: Standard UUIDs  
- `name`, `email`, `company`: Personal/business data
- `random_element`: Pick from provided `elements`
- `random_int`: Integers with `min`/`max` 
- `pyfloat`: Floats with `min_value`/`max_value`
- `now`: Current timestamp

### Entities

Entities represent stateful objects that persist across events. They track mutable state and enable complex relationships:

```python
class Customer(Entity):
    source_event = CustomerRegistered  # Event that creates this entity
    primary_key = "customer_id"        # Field used as unique identifier
    
    # State fields that change over time
    total_orders: int = StateField(default=0, type_=int)
    lifetime_value: float = StateField(default=0.0, type_=float)
    status: str = StateField(default="active", type_=str)
    last_order_date: Optional[datetime] = StateField(default=None, type_=datetime)
    
    # Copy initial values from source event
    registration_date: str = StateField(from_field="registration_date", type_=str)
```

**StateField Options:**
- `default`: Initial value for the field
- `from_field`: Copy value from source event field  
- `type_`: Python type for the field

### Flows

Flows define sequences of related events that model real user behaviors. They can span multiple entities and include realistic timing patterns:

```python
@sim.flow(
    initiation_weight=5.0,  # Relative frequency of flow initiation
    filter=Select(Customer, where=[("status", "is", "active")])  # Entity filters
)
def purchase_flow(ctx: FlowContext):
    """Customer browses and potentially makes a purchase"""
    
    # Browse products
    yield NewEvent(ctx, ProductViewed)
    
    # 30% chance flow ends here (browsing without purchase)
    yield AddDecay(ctx, rate=0.3, seconds=10)
    
    # Add to cart
    yield NewEvent(
        ctx, 
        ProductAdded,
        mutate=SetState(Customer, [("cart_items", "add", 1)])
    )
    
    # Another decay point (cart abandonment)
    yield AddDecay(ctx, rate=0.4, seconds=30)
    
    # Complete purchase
    yield NewEvent(
        ctx,
        OrderCompleted, 
        mutate=SetState(Customer, [
            ("total_orders", "add", 1),
            ("lifetime_value", "add", ctx.current_event_data.get("total", 0))
        ])
    )
```

**Flow Features:**
- **Temporal Patterns**: Use `AddDecay` to model dropout rates
- **Entity Selection**: Filter available entities with `Select`  
- **State Mutations**: Update entity states with `SetState`
- **Context Access**: Get selected entities via `ctx.get_entity()`

### Simulation

The `Simulation` class orchestrates the entire event generation process:

```python
sim = Simulation(
    duration="5m",              # How long to generate events
    start_time="2024-01-01",   # When simulation starts (or "now")
    time_step="1s",            # Time between flow initiations  
    n_flows=10,                # Max concurrent flows
    random_seed=42,            # Reproducible results
    initial_entities={         # Pre-populate entities
        Customer: 100,
        Product: 50
    }
)
```

### Outputs

Deep Faker supports multiple output destinations:

```python
from deep_faker import StdOutOutput, FileOutput, KafkaOutput, MySQLOutput

# Console output
sim.add_output(StdOutOutput())

# File output (JSONL format)
sim.add_output(FileOutput("events.jsonl"))

# Kafka with topic mapping
kafka_topics = {
    UserLogin: "user-events",
    OrderPlaced: "order-events", 
    ProductViewed: "product-events"
}
sim.add_output(KafkaOutput(
    topic_mapping=kafka_topics,
    bootstrap_servers="localhost:9092"
))

# MySQL database
sim.add_output(MySQLOutput(
    host="localhost",
    user="root", 
    database="events",
    table_mapping={UserLogin: "user_logins"}
))
```

## Advanced Patterns

### Multi-Entity Flows

Flows can work with multiple entities simultaneously:

```python
@sim.flow(initiation_weight=3.0)
def order_fulfillment_flow(ctx: FlowContext):
    # Select a customer with pending orders
    customer = ctx.global_context.select_entities(
        Select(Customer, where=[("pending_orders", "greater_than", 0)])
    )[0]
    ctx.add_entity(Customer, customer)
    
    # Select a warehouse for fulfillment
    warehouse = ctx.global_context.get_random_available_entity(Warehouse)
    ctx.add_entity(Warehouse, warehouse)
    
    # Generate fulfillment events
    yield NewEvent(ctx, OrderShipped)
    yield AddDecay(ctx, rate=0.1, hours=24)  # Small chance of delivery issues
    yield NewEvent(ctx, OrderDelivered)
```

### Complex State Mutations

Update entity states with sophisticated operations:

```python
yield NewEvent(
    ctx,
    PaymentProcessed,
    mutate=SetState(Customer, [
        ("account_balance", "subtract", 99.99),
        ("total_spent", "add", 99.99),
        ("last_purchase_date", "is", datetime.now()),
        ("loyalty_points", "add", 100)
    ])
)
```

**Mutation Operations:**
- `"is"`: Set exact value
- `"add"`: Add to current value  
- `"subtract"`: Subtract from current value

### Entity Filtering

Select entities based on their current state:

```python
# Customers who haven't purchased recently
inactive_filter = Select(Customer, where=[
    ("last_purchase_date", "less_than", datetime.now() - timedelta(days=30)),
    ("status", "is", "active")
])

# High-value customers  
vip_filter = Select(Customer, where=[
    ("lifetime_value", "greater_than", 1000.0),
    ("total_orders", "greater_than", 5)
])
```

## Real-World Examples

### E-commerce Platform

See `examples/ecommerce.py` for a complete e-commerce simulation with:
- User registration and authentication
- Product browsing and searching  
- Shopping cart management
- Checkout and payment flows
- Order management and fulfillment

### Trading System

See `examples/trading.py` for financial trading simulation with:
- Market data events
- User trading activities
- Portfolio management
- Risk monitoring events

## Configuration

### Entity Availability

Deep Faker uses implicit state management to ensure entities are available for selection:

- **Available**: Entity can be selected for new flows
- **Active**: Entity is currently being used in a flow
- **Flow Isolation**: Each flow has its own entity context

### Flow Naming

Flows automatically receive names based on their function names, or you can specify custom names:

```python
@sim.flow(initiation_weight=1.0, flow_name="customer_onboarding")
def registration_flow(ctx: FlowContext):
    # Implementation
    pass
```

### Time Management

Each flow maintains its own clock that advances independently:

```python
def long_running_flow(ctx: FlowContext):
    yield NewEvent(ctx, FlowStarted)
    
    # Advance flow time by 1 hour
    yield AddDecay(ctx, rate=0.0, hours=1)
    
    yield NewEvent(ctx, FlowContinued)
    # ctx.flow_clock is now 1 hour ahead
```

## Community

Join our Discord community for support, discussions, and updates:

[![Discord](https://img.shields.io/badge/Discord-Join%20Community-7289da?style=for-the-badge&logo=discord&logoColor=white)](https://discord.gg/UsfVqRsB)

## License

Deep Faker is released under the MIT License. See `LICENSE` for details.

## Contributing

We welcome contributions! Please see `CONTRIBUTING.md` for guidelines.

---

**Deep Faker** - Generate realistic event streams with complex entity relationships and temporal patterns. Perfect for testing, training data generation, and system simulation.